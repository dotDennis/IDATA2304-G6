package group6.ui.controllers;

import java.util.function.Consumer;

import group6.entity.device.ActuatorType;
import group6.entity.device.SensorType;
import group6.entity.device.actuator.Actuator;
import group6.entity.device.sensor.Sensor;
import group6.ui.helpers.ControlNodeConfig;
import group6.ui.helpers.EmbeddedSensorNodeManager;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Service for managing embedded sensor nodes within the GUI.
 * <p>
 * Parts of code generated by AI.
 * And modified to fit our understanding, extra research was necessary.
 * <p>
 * The function of this class is to let the GUI layer create embedded sensor nodes
 * and have them automatically connected to the controller. It also provides
 * methods to remove nodes and restore them from configuration.
 * 
 * @author dotDennis
 * @since 0.2.0
 */
public class EmbeddedNodeService {

  private static final Logger LOGGER = LoggerFactory.getLogger(EmbeddedNodeService.class);

  private final GuiController controller;
  private final EmbeddedSensorNodeManager manager;

  /**
   * Creates a service with a default {@link EmbeddedSensorNodeManager}.
   */
  public EmbeddedNodeService(GuiController controller) {
    this(controller, new EmbeddedSensorNodeManager());
  }

  /**
   * Allows injecting a manager.
   */
  public EmbeddedNodeService(GuiController controller, EmbeddedSensorNodeManager manager) {
    this.controller = controller;
    this.manager = manager;
  }

  /**
   * Returns the underlying manager for direct access when required.
   */
  public EmbeddedSensorNodeManager getManager() {
    return manager;
  }

  /**
   * Creates an embedded node and immediately connects the GUI controller to it.
   */
  public EmbeddedSensorNodeManager.EmbeddedNode createAndConnect(String nodeId,
                                                                 String host,
                                                                 int port,
                                                                 long refresh)
      throws Exception {
    EmbeddedSensorNodeManager.EmbeddedNode node = manager.createNode(nodeId, host, port, refresh);
    controller.connectToNode(nodeId, host, port);
    return node;
  }

  /**
   * Removes the node both from the manager and the global registry.
   */
  public void removeNode(String nodeId) {
    manager.removeNode(nodeId);
  }

  /**
   * Recreates nodes/devices from config and invokes callbacks for UI updates.
   */
  public void restoreNodes(ControlNodeConfig.Entry config,
                           Consumer<EmbeddedSensorNodeManager.EmbeddedNode> onNodeRestored,
                           Consumer<String> errorHandler) {
    if (config == null || config.getSensorNodes() == null) {
      return;
    }
    for (ControlNodeConfig.SensorNodeEntry nodeEntry : config.getSensorNodes()) {
      try {
        String host = nodeEntry.getHost() == null ? "localhost" : nodeEntry.getHost();
        EmbeddedSensorNodeManager.EmbeddedNode node = createAndConnect(
            nodeEntry.getId(), host, nodeEntry.getPort(), nodeEntry.getRefreshInterval());
        loadDevices(nodeEntry, node.getNodeId());
        if (onNodeRestored != null) {
          onNodeRestored.accept(node);
        }
      } catch (Exception e) {
        LOGGER.warn("Failed to restore node {}", nodeEntry.getId(), e);
        if (errorHandler != null) {
          errorHandler.accept("Failed to restore node " + nodeEntry.getId() + ": " + e.getMessage());
        }
      }
    }
  }

  /**
   * Builds a config snapshot of all embedded nodes.
   */
  public ControlNodeConfig.Entry buildConfigEntry(String id, String displayName, long refreshInterval) {
    ControlNodeConfig.Entry entry = new ControlNodeConfig.Entry();
    entry.setId(id);
    entry.setDisplayName(displayName);
    entry.setRefreshInterval(refreshInterval);

    for (EmbeddedSensorNodeManager.EmbeddedNode node : manager.listNodes()) {
      ControlNodeConfig.SensorNodeEntry nodeEntry = new ControlNodeConfig.SensorNodeEntry();
      nodeEntry.setId(node.getNodeId());
      nodeEntry.setHost(node.getHost());
      nodeEntry.setPort(node.getPort());
      nodeEntry.setRefreshInterval(node.getSensorNode().getSensorNodeInterval());

      for (Sensor sensor : node.getSensorNode().getSensors()) {
        nodeEntry.getSensors().add(
            new ControlNodeConfig.DeviceEntry(sensor.getDeviceId(), sensor.getDeviceType().name(), sensor.getUpdateInterval()));
      }
      for (Actuator actuator : node.getSensorNode().getActuators()) {
        nodeEntry.getActuators().add(
            new ControlNodeConfig.DeviceEntry(actuator.getDeviceId(), actuator.getDeviceType().name()));
      }
      entry.getSensorNodes().add(nodeEntry);
    }
    return entry;
  }

  /**
   * Rehydrates sensors and actuators from a config entry onto the given node.
   */
  private void loadDevices(ControlNodeConfig.SensorNodeEntry nodeEntry, String targetNodeId) {
    if (nodeEntry.getSensors() != null) {
      for (ControlNodeConfig.DeviceEntry entry : nodeEntry.getSensors()) {
        try {
          SensorType type = SensorType.valueOf(entry.getType());
          manager.addSensor(targetNodeId, type, entry.getId(), entry.getUpdateIntervalMs());
        } catch (Exception e) {
          LOGGER.warn("Failed to restore sensor {} on {}", entry.getId(), targetNodeId, e);
        }
      }
    }
    if (nodeEntry.getActuators() != null) {
      for (ControlNodeConfig.DeviceEntry entry : nodeEntry.getActuators()) {
        try {
          ActuatorType type = ActuatorType.valueOf(entry.getType());
          manager.addActuator(targetNodeId, type, entry.getId());
        } catch (Exception e) {
          LOGGER.warn("Failed to restore actuator {} on {}", entry.getId(), targetNodeId, e);
        }
      }
    }
  }
}
